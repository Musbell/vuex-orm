# Interact With Store From Model

As an alternative to calling store methods directly, you may access the store instance from a model as well to dispatch actions or call getters.

```js
const user = User.dispatch('create', { data: ... })

// The above code is exactly same as below.

const user = store.dispatch('entities/users/create', { data: ... })
```

Also, the model is capable of calling all of the store actions and getters such as `create` and `find`.

```js
User.create({
  data: [
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Jane Doe' }
  ]
})

const user = User.find(2)
```

Accessing the store from a model does nothing special compared to accessing the store directly. It's just for the convenience. Hence you may choose whichever way fits your preference.

## Accessing Store Instance

You can access the store instance via the `store` method.

```js
// As static method.

const store = User.store()

// As instance method.

const user = new User()

const store = user.$store()
```

### Dispatching Action

You can dispatch an action via the `dispatch` method. The `dispatch` method in the model will automatically be namespaced, so you don't have to pass in the root namespace or entity name as an argument.

```js
// As static method.

User.dispatch('create', { data: ... })

// As instance method.

const user = new User()

user.$dispatch('create', { data: ... })
```

As you can see, in the above example we didn't call the dispatch action as `entities/users/create`, because the `entities/users` part is generated by the model.

### Calling Getters

You can call getters via the `getters` method. Be aware that getters in the model should be called as a method, not via the array accessing syntax.

```js
// As static method.

const user = User.getters('find')(1)

// As instance method.

const user = new User()

const users = user.$getters('all')()
```

The same as actions, getters in the model is also namespaced automatically.

## Dispatching Persist Method

The model can dispatch all of the persist methods, which are `create`, `insert`, `new`, `update` and `insertOrUpdate`. You may call them through static and instance methods. Note that you need to prefix the method name with `$` when dispatching methods by the instance method.

```js
// As static method.

User.create({ data: { ... } })

// As instance method.

const user = new User()

const users = user.$create({ data: { ... } })
```

When calling `update` as an instance method, you may omit the primary key since the model instance already has it.

```js
const user = User.find(1)

user.$update({ age: 24 }) // <- Updates where user has id of 1.
```

## Dispatching Persist Method

You may call getters through models as well. All `all`, `find` and `query` getters are available.

```js
const users = User.all()

// You can chain the query too.
const users = User.query().where('active', true).get()
```

## Delete Method

You can call delete actions through models the same as other methods. Like `update`, you may omit the primary key value when calling the delete method through instance method.

```js
User.delete(1)

// You can omit id with instance method.

const user = User.find(1)

user.$delete()
```

## Interacting With State

Within Vuex Store, each Model has a corresponding state tree. For example, if you have User Model, inside Vuex Store would look like this.

```js
{
  entities: {
    users: {
      data: [ ... ]
    }
  }
}
```

You can see there's `data` property under `users`. Here is where all of the user records will be stored. However, you may add any number of state property other than `data` and interact with them through Model method.

### Defining State

To define state, define `static state` property at Model.

```js
class User extends Model {
  static entity = 'users'

  static state = {
    fetching: false
  }

  static fields () {
    return { ... }
  }
}
```

State definition can also be declared as a function too.

```js
class User extends Model {
  static state () {
    return {
      fetching: false
    }
  }
}
```

With the above definition, the state inside Vuex Store would become like this.

```js
{
  entities: {
    users: {
      fetching: false,
      data: [ ... ]
    }
  }
}
```

### Mutating State

To mutate state, you may use `static commit` method in Model.

```js
User.commit((state) => {
  state.fetching = true
})
```

The `static commit` method receives `state` object as same as usual Vuex Mutation, and you may mutate any field using the state.

Note that the callback function passed to the `commit` method is called within the Vuex Mutation handler. Which means, the callback should always follow the rule for the mutations that it must be syncronaus.
